\newpage
\safeoldsection[Подготовительные работы для портирования OpenJDK]{Подготовительные работы для\newline портирования OpenJDK}

Для разработки порта под другую платформу необходимо сделать некоторые предварительные шаги для инициализации всей работы. Этот этап разработки выполнялся совместно, в команде из 4 человек. 
Далее, на протяжении данной главы, о задачах, выполненных индивидуально, будет оговариваться отдельно.

% \TODO{ возможный перефраз: Далее, на протяжении данной главы, будут делаться уточнения, если задача выполнялась индивидуально.}



\subsection[Настройка обеспечения для разработки на базе RISC-V]{Настройка обеспечения для разработки\newline на базе RISC-V}

Процессоры, произведенные на базе архитектуры RISC-V ещё не поступили в массовое производство, а тестовые образцы поставляются в очень ограниченном количестве и приобрести их проблематично из-за высокого спроса на рынке. В связи с этой проблемой единственным доступным способом является разработка на эмуляторе RISC-V, способным запустить операционную систему.

Был найден QEMU эмулятор RISC-V \cite{riscv:qemu}, который ещё находится в разработке, но уже способен запускать linux и работать безошибочно для большинства задач, а также выбран RISC-V GNU toolchain \cite{riscv:gnu}, содержащий необходимые инструменты разработки для кросс-компиляции\footnote{Компиляции кода на платформу, отличную от той, на которой запущен кросс-компилятор} и отладки \cpp кода на RISC-V. Были написаны docker\footnote{Программа для удобной контейнеризации и развертки программных сред} образы для более удобной командной разработки и переносимости настроенного окружения. Также были написаны скрипты для упрощенного запуска данных образов с монтированием директорий и настройкой всех необходимых параметров.

Для отладки был использован GDB из RISC-V GNU toolchain, который работал с кодом, выполняющимся на QEMU, посредством клиент-серверного взаимодействия, так как возможностей GDB, реализованного на RISC-V, не хватало для тщательной отладки. Однако, подобное взаимодействие усложнило настройку GDB, поэтому были написаны специальные скрипты для запуска сервера и клиента с различными флагами, а также подключением отладочных символов проекта.
    
    
\subsection{Настройка OpenJDK}

Для проверки корректности настроенного окружения было решено запустить zero порт OpenJDK, который написан на \cpp и является почти полностью кроссплатформенным, однако для его запуска было необходимо избавиться от ошибок компиляции, возникающих в платформозависимых вставках в общей для всех портов части кода. В итоге, zero порт успешно запустился на эмуляторе RISC-V, и инициализация Java машины на нём занимала около двух минут, что демонстрирует низкую производительность QEMU и zero порта.

% \TODO{Стоит ли писать про настройку индексации в Clion?}
% Также мы смогли настроить clion для работы с OpenJDK и её корректной индексации, что, в целом, не предполагается разработчиками Java

Ради ускорения разработки мы выбрали стандартный метод портирования, заключающийся в копировании исходного кода некого порта и его постепенном переписывании. Для данной цели решено было выбрать порт PowerPC, так как его код показался чище, а архитектура ближе к RISC-V, чем другие. Тем не менее, данный выбор не является критичным или ключевым, и был сделан, по большей части, из соображений удобства, а при решении некоторых задач мы смотрели на реализацию других портов OpenJDK.

Прежде чем приступить к платформозависимой реализации интерпретатора, были устранены ошибки компиляции, вызванные копированием другого порта, а также настроить некоторые платформозависимые части общего для всех портов кода.


\subsection{Реализация базовой функциональности порта}

Процесс интерпретации происходит с помощью ассемблерного кода, генерирующегося при инициализации JVM. В общей части OpenJDK реализован фреймворк, с помощью которого можно написать свой генератор ассемблерного кода. Для этого были воссозданы все правила генерации кодов инструкций, описанные в спецификации RISC-V, и таким образом генератор был реализован. 

В OpenJDK реализован код, который печатает файл с ошибками и состоянием системы при исключительных ситуациях и экстренном выходе из программы. Основная часть данной реализации зависит одновременно от операционной системы и архитектуры процессора. Было решено написать эту часть и для нашего порта, что помогло бы ускорить нахождение ошибок, возникающих при написании системы, эта задача выполнялась индивидуально. Однако, из-за неизвестной ошибки в эмуляторе, значение всех регистров портилось при обработке ошибок на процессоре. Данное поведение помешало разработке, и процесс был остановлен на полпути. Позднее, разработчики QEMU исправили данную ошибку в своей новой версии, однако данная часть так и осталась нереализованной в связи с более важными возникающими задачи.


\subsection{Выводы}

В качестве системы исполнения кода был выбран эмулятор QEMU, а для компиляции и отладки кода был выбран RISC-V GNU toolchain, и всё это было положено в docker образы для удобной дальнейшей работы. Окружение было успешно настроено, что было проверено запуском zero порта. Для процесса портирования был выбран PowerPC порт в качестве основы для реализации, также был написан генератор ассемблерного кода RISC-V, и предпринята попытка реализации кода, отвечающего за печать ошибок виртуальной машины, которая оказалось неуспешной из-за ошибки в QEMU.


