\newpage
\safeoldsection[Кэширование информации интерпретатора]{Кэширование информации\newline интерпретатора}

Обращение к памяти на стеке для чтения или записи является долгой операцией, поэтому мы хотим уменьшить количество таких обращений. В процессе работы интерпретатора нам нужно часто обращаться к одним и тем же данным, которые лежат где-то в памяти, и можно такие данные или адреса на них положить в специальные регистры, значения в которых не будут портиться при вызовах C функций, так как по общему соглашению значения этих регистров должно быть одинаковым до и после вызова функции, а потому их называют неизменяемыми. Всего в архитектуре RISC-V 12 неизменяемых регистров, один из которых используется, как fp регистр. В итоге получается 11 регистров, которые мы можем использовать под свои нужды. На каждой архитектуре разное количество этих регистров, на PowerPC их 18, и нам не хватает регистров, чтобы закэшировать всю информацию, что кэшируется в PowerPC, а потому было решено провести исследование со сбором статистики использования данных регистров, чтобы выбрать наиболее необходимые.



\subsection{Выбор источников для сбора статистики}

Сбор статистики должен производиться из объективных источников, чтобы реальные пользователи OpenJDK смогли ощутить схожий с нашими данными прирост производительности. Таким образом, было выбрано 3 основных источника.
Первый - инициализация JVM, которая происходит при каждом запуске Java приложений, и, что не менее важно, основная его работа происходит без использования JIT компиляции, что делает данные замеры ещё более объективными.
Второй источник - Renaissance Suite \cite{renaissance}, тест производительности, основанный на реальных приложениях, использующий в своих тестах библиотеки scala, spark и прочие жизненные примеры использования JVM, данный тест является новым, объемным и широко распространенным.
Третий источник - SPECjvm2008, это первый, популярный в свое время, тест производительности Java, основанный на реальных приложениях.

Одной из задач данной работы было создание универсальных полуавтоматических инструментов, позволяющих получать данные из любых источников, что могло бы значительно ускорить работу по корректировке и перепроверке результатов, поэтому рассмотренные источники могут быть дополнены в будущем, а цель текущего их выбора состоит в базовой проверке гипотез и получения начальных объективных, но не факт, что полных, данных. 



\subsection{Ручной сбор статистики}

Первой идей сбора данных был ручной подсчет использования регистров в байткодах, а далее, используя статистику по количеству исполненных байткодов, собранных с помощью инструментов OpenJDK, можно было бы получить общую статистику по количеству использования регистров в порте. Целью данного сбора было выявление сильноиспользуемых и малоиспользуемых регистров, которые уже используются в PowerPC порте, и в большинстве своем в RISC-V. Данные собирались по ещё недописанному порту RISC-V, однако на момент сбора статистики было реализовано уже порядка 80 процентов байткодов, остальные же брались из предположения, что используемые данные на разных портах не сильно различаются.

В итоге мы хотели получить количество обращений к памяти к каждому полю, если бы оно не было закэшировано, что означает, что простым подсчетом количества использований обойтись не получится, так как можно загрузить данные во временный регистр один раз и потом обращаться к ним много раз во время интерпретации байткода. Автоматический сбор таких данных тоже маловозможен, преимущественно из-за очень сложной интерпретации измененния данных. Автоматически нельзя понять, после каких изменений данные необходимо записать в память, а какие изменения можно расчитывать во временных регистрах. Также все временные регистры теряют информацию после каждого Runtime вызова, что тоже усложняет расчеты. В дополнение к этому, при вызове некоторых функций мы можем передать значения внутрь, изменив их сигнатуру, что избавило бы от лишнего взятие данных внутри функции, если было необходимо взять их ещё и снаружи. В конце концов, целью было произвести подсчет для порта RISC-V, а он ещё находится в состоянии разработки, и не может полностью обработать вычисления из выбранных источников. 

Все наложенные ограничения привели к необходимости производить подсчет вручную, а именно, посчитать приближенное количество загрузок и сохранения данных для каждого значения, если бы оно не было сохранено в регистр. Данная информация была подсчитана для каждого из 128 методов, и всех методов, вызываемых в процессе их исполнения, которые обеспечивают работу 251 байткода. Все полученные результаты были занесены в таблицу, а также были настроены формулы по автоматическому пересчету значений, позволяющие в конечном счете загрузить в таблицы статистику по исполнению байткодов и автоматически получить статистику по использованию данных.

Данный подсчет не учитывает код, вызываемый на момент создания фреймов, или же код, переключающий байткоды, потому что эти данные сложнее получить без существенных модификаций порта x86\_64, на котором осуществлялся сбор статистики по исполнению байткодов, из расчета на то, что Java компилируется в одинаковый набор байткодов на каждой платформе. Однако некоторые изменения пришлось внести в связи с тем, что счетчики байткодов переполнялись при анализе Renaissance Suite, поэтому необходимо было внести модификации, чтобы статистика считалась для 64-битных значений.



\subsection{Автоматический сбор статистики}

После проведения ручного сбора статистики захотелось провести более подробный анализ данных, чтобы посчитать не только использование уже закэшированных данных, но и данных, которые потенциально можно было бы закэшировать. Поскольку мы не знали всех данных, которые хотим посчитать, заранее, а также нам хотелось бы иметь возможность не учитывать какие-то данные, либо добавлять новые, то ручной сбор уже не подходил, но и проблемы автоматического не исчезли. Идеальной архитектурой для данного сбора был бы порт, у которого было бы бесконечное количество временных регистров, и ни одного неизменяемого, чтобы каждый раз обращение к данным происходило через память, но чтобы данные сохранялись во временных регистрах и использовались через них, пока это возможно. Такого порта не существует, однако архитектура x86\_64 наиболее близка к подобному, и имея посчитанную вручную статистику для немногих закэшированных на ней данных, можно было бы собрать автоматическую статистику на всех остальных. 

Данный подход потребовал переписать сотни обращений к памяти, проинструментировать их для сбора статистики, что оказалось долгой и неприятной задачей. Также мы столкнулись с проблемой интерпретации получаемых данных, так как все хитрые зависимости и условности при использовании данных, которые были посчитаны вручную, теперь не работали и необходимо было учитывать их как-то автоматически, что сделать полностью было невозможно. Из-за сильной иерархичности доступа к данным была добавлена возможность вести подсчет без учета доставаемыех предков в иерархии доступа, например, если в структуре method лежит структура constMethod, а в ней cachePool, то при загрузке всех трех полей послеовательно в статистике будет учтена только загрузка cachePool. Подобные усложнения помогли избавиться от некоторых проблем с интерпретацией данных, однако породили сильные зависимости между собранными данными и усложнили общий подход к их интерпретации. Также не получилось полностью учесть весь контекст, и для интерпретации данных периодически необходимо анализировать код, чтобы их понять, например, если мы загружаем три разных поля из структуры constMethod примерно одинаковое количество раз, мы не можем без анализа кода сказать, нужно ли нам все эти три раза было грузить constMethod, или они все грузятся после того, как constMethod был загружен в другой временный регистр. Ещё большую путаницу вводит то, что на x86\_64 количество временных регистров не бесконечно и сильно меньше, чем у RISC-V, поэтому периодически данные грузятся по несколько раз, где в RISC-V можно было бы загружать их только один.

Все перечисленные факторы существенно замедлили процесс анализа данных, что, в совокупности с общим объемом работы и возникающими непредвиденными трудностями в процессе инструментирования обращений, не позволило провести расчеты для всех данных, использующихся в порте. Часть данных была выбрана из соображений проверки ручного сбора данных, остальные были выбраны из представления о частоте их использования по количеству их встречаемости в коде.



\subsection{Обработка результатов}

Для обработки результатов с первого метода были использованы флаги OpenJDK \textit{PrintBytecodeHistogram} и \textit{ActiveProcessorCount=1}, чтобы распечатать статистику по выполненным байткодам и сделать исполнение кода на одном процессе, иначе подсчет статистики будет собираться некорректно. Для запуска Renaissance Suite использовались параметры \textit{\texttt{--}functional\texttt{-}test \texttt{-}r 1 all}, а для SPECjvm2008 \textit{\texttt{-}mi 1 \texttt{-}ma 1 \texttt{-}bt 1 \texttt{-}ikv}.

Всего в инициализации JVM было исполнено 48 миллионов байткодов, в Renaissance Suite 225.7 миллиардов, а в SPECjvm2008 628.7 миллионов. По данным ручного сбора распределения по использованию данных в процентах от их общего числа в инициализации JVM и в Renaissance Suite близки друг к другу, в SPECjvm2008 ситуация отличается некритично, там выше процент использования локалов и указателя на байткод, что обусловлено большим процентом математических и околоматематических байткодов, которые много оперируют со стеком и данным указателем.

С помощью автоматического тестирования удалось найти и исправить некоторые ошибки ручного тестирования, после данного исправления по ручному тестированию мы видим данный результат на инициализации VM: регистры указателя на байткод (bcp), текущего потока (threads), локалов (locals), верхушки стека вычислений (TOS) и начала фрейма (fp) используются десятки миллионов раз. Автоматически собранная статиста показывает, что таблица диспетчеризации (dispatch\_table) используется 48 миллионов раз, в ручном сборе она используется ноль раз, ибо отрабатывает только в исключительных случаях, которые не учитывались. Данная разница просто объясняется тем, что данное значение используется при переходе между байткодами и не учитывается в ручном подсчете. Также в ручном подсчете не полностью учитывается указатель на стек вычислений (esp), 7 миллионов в ручном сборе и 58 при автоматическом. Данное отличие обусловлено изменением данного показателя между байткодами, а из-за частой изменяемости значения, при каждом обращении нужно делать и загрузку, и сохранение в память, что удваивает количество обращений к памяти. Указатель на конец предыдущего фрейма (sender\_sp) используется только при возврате из метода, которых было около 2.5 миллионов, и надобность в данном кэшировании минимальна. Регистр таблицы содержания (TOC) в шаблонном интерпретаторе не используется в принципе, он нужен только для JIT компиляции, а значит можно в будущем заменить его на регистр, не использующийся в JIT компиляции, например locals. Регистр мониторов (monitors) показывает также крайне низкие показатели - почти 6 тысяч в ручном тестировании и 112 в автоматическом. Данная разница сильно проявляется из-за неучтенных в ручном тестировании вызовов синхронизированных методов, которые прибавляют 106 тысяч использований. Данный регистр является самым неоднозначным из всех вышеперечисленных, так как его использование очень сильно зависит от специфики приложений, и в будущем необходимо найти программу с преобладающими параллельными вычислениями, чтобы собрать данные и посмотреть на реальное использование данного регистра. Если даже в параллельной среде этот регистр задействован слабо, то можно избавиться от его кэширования, но если же он проявляет свою необходимость в данных приложениях, то стоит его оставить для большей универсальности OpenJDK порта. Остались регистры с кэшем хранилища констант (const\_pool) и метода (method), которые используются по 6-7 миллионов раз, если сопоставить ручную и автоматическую статистики. Данные показатели не очень высокие, но пока им не нашлось достойной замены.

Автоматический сбор успешно справился с задачей проверки и уточнения ручного сбора статистики, однако, несмотря на вдвое большее количество рассмотренных данных, более удачных кандидатов на кэширование ещё не удалось выявить. Также не были рассмотрены регистры, необходимые для кэширования данных, помогающих облегчить отладочные сборки, профилирование OpenJDK, а также прочих побочных путей исполнения, в связи с тем, что в этих задачах скорость исполнения не является приоритетной ценностью, и ей можно пожертвовать при необходимости. 


\subsection{Выводы}

Были разработаны две методики сбора данных, которые отлично показали себя именно в совокупном использовании. Незначительные отличия в данных с выбранных источников показывают их объективность. В результате удалось выяснить крайнюю важность таких регистров, как bcp, TOS, esp, threads, locals, fp и dispatch\_table. Также свою полезность продемонстрировало кэширование method и const\_pool. Если monitors и sender\_sp показали весьма сомнительные результаты, и потенциально от них можно избавиться, то от кэширования TOC в интерпретаторе нет никакой пользы, его можно кэшировать его только при входе в JIT компиляцию, если это технически возможно.

Данное исследование оказалось более трудоемким, чем изначально предполагалось, что, в итоге, повлияло на его неполноту и незаконченность некоторых результатов. Однако уже на данном этапе были сделаны выводы относительно использования, либо потенциального использования регистров в RISC-V порте, что так или иначе будет учтено при его дальнейшей разработке. Также интересным бонусным результатом был вывод о том, что можно ускорить порт PowerPC, добавив в него отсутствующее кэширование fp регистра, что можно сделать, использовав ещё незадействованный регистр, либо же заменив на него sender\_sp.

Потенциальным продолжением данного исследования может быть задействование изменяющихся регистров в качестве кэшируемых, при сохранении их на стек при каждом Runtime вызове. Подобное исследование завязано не только на полной статистике по использованию данных, но и на полном анализе использования изменяемых регистров в коде, количество которых также весьма ограничено. 
