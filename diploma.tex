% В этом шаблоне используется класс spbau-diploma. Его можно найти и, если требуется, 
% поправить в файле spbau-diploma.cls
\documentclass[14pt]{spbau-diploma}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра математических и информационных технологий},
    title              = {Пустое подмножество как замкнутое множество},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = 666,
    author             = {Машкин Эдельвейс Захарович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Выбегалло А.\,А.},
    reviewerPosition   = {ст. преп.},
    reviewer           = {Привалов А.\,И.},
    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    chairHead          = {Омельченко А.\,В.},
    % university = {САНКТ-ПЕТЕРБУРГСКИЙ АКАДЕМИЧЕСКИЙ УНИВЕРСИТЕТ},
    % faculty = {Центр высшего образования},
    % city = {Санкт-Петербург},
    % year             = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}

\section*{Обзор литературы}
\subsection*{Выводы}

\section*{Аннотация}
\section*{Abstract}


\section{Подготовка окружения для написания OpenJDK порта}
\subsection{Настройка программ для разработки RISC-V}
\subsection{Настройка и реализация ключевой функциональности порта}

\section{Разработка и реализация фреймов}
Структуры фреймов в OpenJDK являются ключевым элементом ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время интерпретации методов; способ взаимодействия Java методов, как друг с другом, так и с JNI и Runtime методами, вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры фреймов, чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.

\subsection{Разработка структуры фреймов}
Первой задачей разработки структуры фреймов было нахождение или составление описания нативных фреймов для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group \cite{lecture:frames}, не являются официальным документом от разработчиков компилятора языка C, поэтому их необходимо было проверить, для чего использовался метод обратной инженерии. Были написаны разные программы на языке C, в которых были отражены ключевые сценарии вызовов функций, передачи аргументов и работы с локальными переменными, после чего данный код был скомпилирован с помощью RISC-V GNU GCC \cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение фреймов. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для создания структуры Java фреймов. 

Проектирование структуры Java фреймов для RISC-V было основано на структуре фреймов для архитектуры PowerPC, однако существенные различия в нативных фреймах данных архитектур оказывали существенное влияние, а именно: нативный ABI RISC-V фреймов содержит только адрес в памяти, указывающий на последний байт перед предыдущим фреймов, и адрес возврата для текущего метода, в то время как 
От PPC здесь немало отличий, например, наличие fp регистра, указывающего на начало фрейма, также отличается расположение данных, их количество и прочие нюансы. 
Из-за специфики RISC-V над многим пришлось сильно подумать и изменить всё необходимое, например, мы почти убрали различие последнего IJava фрейма от предыдущих, чего нельзя было сделать в PPC из-за ограничений, связанных с ABI. Также было решено сделать размер фрейма фиксированным, т.к. RISC-V требует выравнивания sp регистра, указывающего на конец фрейма, на 16 байт, а для работы со стеком выражений решено было зарезервировать специальный регистр.
OpenJDK не мало обращается к данным фреймов из runtime вызовов, и для этого было необходимо реализовать все нужные функции для корректного обращения ко всем полям фрейма и обхождения фреймов, что весьма специфично для разных платформ. 


\subsection{Реализация Entry фрейма}
\subsection{Реализация IJava фрейма}
\subsection{Реализация Native фрейма}

\section{Кэширование информации интерпретатора}
\subsection{Использование регистров для кэширования в портах}
\subsection{Выбор источников для сбора статистики}
\subsection{Сбор статистики}
\subsection{Обработка результатов}

\section{Тестирование результатов}  
\subsection{Проблематика и направленность тестирования}
\subsection{Этапы тестирования}


% У заключения нет номера главы
\section*{Заключение}


\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
