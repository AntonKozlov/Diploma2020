% В этом шаблоне используется класс spbau-diploma. Его можно найти и, если требуется, 
% поправить в файле spbau-diploma.cls
\documentclass[14pt]{spbau-diploma}
\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра математических и информационных технологий},
    title              = {Пустое подмножество как замкнутое множество},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {master},
    position           = {студента},
    group              = 666,
    author             = {Машкин Эдельвейс Захарович},
    supervisorPosition = {д.\,ф.-м.\,н., профессор},
    supervisor         = {Выбегалло А.\,А.},
    reviewerPosition   = {ст. преп.},
    reviewer           = {Привалов А.\,И.},
    chairHeadPosition  = {д.\,ф.-м.\,н., профессор},
    chairHead          = {Омельченко А.\,В.},
    % university = {САНКТ-ПЕТЕРБУРГСКИЙ АКАДЕМИЧЕСКИЙ УНИВЕРСИТЕТ},
    % faculty = {Центр высшего образования},
    % city = {Санкт-Петербург},
    % year             = {2013}
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}

\section*{Обзор литературы}
\subsection*{Выводы}

\section*{Аннотация}
\section*{Abstract}


\section{Подготовка окружения для написания OpenJDK порта}
\subsection{Настройка программ для разработки RISC-V}
\subsection{Настройка и реализация ключевой функциональности порта}

\section{Разработка и реализация фреймов}
Структуры фреймов в OpenJDK являются ключевым элементом ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время интерпретации методов; способ взаимодействия Java методов, как друг с другом, так и с JNI и Runtime методами, вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры фреймов, чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.

\subsection{Разработка структуры фреймов}
Первой задачей разработки структуры фреймов было нахождение или составление описания нативных фреймов для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group \cite{lecture:frames}, не являются официальным документом от разработчиков компилятора языка C, поэтому их необходимо было проверить, для чего использовался метод обратной инженерии. Были написаны разные программы на языке C, в которых были отражены ключевые сценарии вызовов функций, передачи аргументов и работы с локальными переменными, после чего данный код был скомпилирован с помощью RISC-V GNU GCC \cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение фреймов. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для создания структуры Java фреймов. 

Проектирование структуры Java фреймов для RISC-V было основано на структуре фреймов для архитектуры PowerPC, однако существенные различия в нативных фреймах данных архитектур оказали соответственное влияние, а именно: нативный ABI RISC-V фреймов содержит только адрес в памяти, указывающий на последний байт перед предыдущим фреймов, и адрес возврата для текущей функции, в то время как у PowerPC хранится последний байт перед текущим фреймом, записывается адрес возврата вызываемой функции, имеется зарезервированное место под первые 8 аргументов и все эти значения лежат внизу фрейма, а не наверху, как в RISC-V.
Данные отличия, а также наличие регистра fp, указывающего на последний байт предыдущего фрейма, повлекли изменения в реализации методов, которые помогают осуществить просмотр данных фрейма и навигацию между фреймами во время исполнения внутренних Runtime вызовов.

Одной из особенностей архитектуры RISC-V является обязательное выравнивание вниз на 16 байт значения в регистре sp, которое должно указывать на последний байт текущего фрейма. Во время интерпретации периодически делаются Runtime вызовы, в которых необходимо соблюдать данное выравнивание, что приводит к выбору одного из возможных вариантов решения данной проблемы: 
\begin{enumerate}
    \item Применять выравнивание ко всем данным, выкладываемым на стек.
    \item Применять выравнивание к значению в регистре sp при каждом Runtime вызове.
    \item Создавать фрейм фиксированного размера и выкладывать все данные внутри него.
\end{enumerate}

Первый вариант нам не подходит из-за того, что размер данных на стеке увеличится примерно в 2 раза, что является неоправданными тратами памяти. Третий вариант требует небольших накладных расходов памяти на поддержание места под значения, которые не всегда необходимо сохранять в памяти, однако отсутствие постоянной необходимости в выравнивании ускорит Runtime вызовы и избавит нас от потенциальных проблем с этим.

\subsection{Реализация Entry фрейма}
\subsection{Реализация IJava фрейма}
\subsection{Реализация Native фрейма}

\section{Кэширование информации интерпретатора}
\subsection{Использование регистров для кэширования в портах}
\subsection{Выбор источников для сбора статистики}
\subsection{Сбор статистики}
\subsection{Обработка результатов}

\section{Тестирование результатов}  
\subsection{Проблематика и направленность тестирования}
\subsection{Этапы тестирования}


% У заключения нет номера главы
\section*{Заключение}


\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}
