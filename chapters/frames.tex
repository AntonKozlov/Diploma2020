\section{Разработка и реализация фреймов}

Структуры фреймов в OpenJDK являются ключевым элементом ABI всего интерпретатора и определяют такие вещи, как выбор и способ сохранения необходимой информации во время интерпретации методов; способ взаимодействия Java методов, как друг с другом, так и с JNI и Runtime методами, вызываемыми в процессе интерпретации; семантику взаимодействия со стеком вычислений, локальными значениями и аргументами. Правильное создание данных структур должно опираться как на нативную реализацию структуры фреймов, чтобы сохранить совместимость с нативными вызовами и инструментами отладки, так и на создание и использование этих структур в интерпретации, чтобы обеспечить максимально быструю работу приложения.



\subsection{Разработка структуры фреймов}

Первой задачей разработки структуры фреймов было нахождение или составление описания нативных фреймов для языка C. Данные, найденные в онлайн лекции Parallel \& Distributed Operating Systems Group \cite{lecture:frames}, не являются официальным документом от разработчиков компилятора языка C, поэтому их необходимо было проверить, для чего использовался метод обратной инженерии. Были написаны разные программы на языке C, в которых были отражены ключевые сценарии вызовов функций, передачи аргументов и работы с локальными переменными, после чего данный код был скомпилирован с помощью RISC-V GNU GCC \cite{riscv:gnu} компилятора в ассемблерный код RISC-V, после чего в нём были выявлены места, отвечающие за создание и заполнение фреймов. Семантика данного кода полностью соответствовала найденной структуре, и было принято решение использовать её в качестве основы для создания структуры Java фреймов. 

Проектирование структуры Java фреймов для RISC-V было основано на структуре фреймов для архитектуры PowerPC, однако существенные различия в нативных фреймах данных архитектур оказали соответственное влияние, а именно: нативный ABI RISC-V фреймов содержит только адрес в памяти, указывающий на последний байт перед предыдущим фреймов, и адрес возврата для текущей функции, в то время как у PowerPC хранится последний байт перед текущим фреймом, записывается адрес возврата вызываемой функции, имеется зарезервированное место под первые 8 аргументов и все эти значения лежат внизу фрейма, а не наверху, как в RISC-V.
Данные отличия, а также наличие регистра fp, указывающего на последний байт предыдущего фрейма, повлекли изменения в реализации методов, которые помогают осуществить просмотр данных фрейма и навигацию между фреймами во время исполнения внутренних Runtime вызовов.

    Одной из особенностей архитектуры RISC-V является обязательное выравнивание вниз на 16 байт значения в регистре sp, которое должно указывать на последний байт текущего фрейма. Во время исполнения кода необходимо соблюдать данное выравнивание, что означает выбор одного из трех решений:
\begin{enumerate}
    \item Применять выравнивание ко всем данным, выкладываемым на стек.
    \item Помнить невыровненное смещение относительно sp, при работе со стеком сдвигать и его, и значение в sp.
    \item Создавать фрейм фиксированного размера и выкладывать все данные внутри него.
\end{enumerate}

Первый вариант нам не подходит из-за того, что размер данных на стеке увеличится примерно в 2 раза, что является неоправданной тратой памяти. Решено было выбрать третий, так как хоть он и требует небольших накладных расходов памяти на поддержание места под значения, которые не всегда необходимо сохранять в памяти, однако, в отличие от второго, он не усложняет работу со значениями на стеке, что может существенно замедлить процесс интерпретации.



\subsection{Реализация Entry фрейма}

\subsection{Реализация IJava фрейма}

\subsection{Реализация Native фрейма}
